# コンベンションセンターをサーバレスで実現する

コンベンションセンター、まあ要するにアイドル別掲示板である。これをサーバレスでやってみたい、というわけである。実現するに当たっては、いろいろなところの助けを借りつつ、こんな感じの構成にした。

- Amazon AWSを用いる
- フロント側はVue.js+TypeScriptを用いる
- バックエンドはデータベースとしてDynamoDBを用いて、各種エンドポイントはLambda+API Gatewayを用いる
- Lambdaの言語はPython3を用いる
- 認証基盤はCognitoを用いて、Google認証に対応する

なお、将来的に同じ構成を用いる可能性があり得たため(常設するか、それとも年度ごとに廃棄して作り直すか未定だったこともあり)、今回はCloudFormationによるバックエンド側のデプロイを採用することにした。フロントエンド側はS3+CloudFrontの構成なので、これはデプロイ機能は後回しにする予定である。

## CloudFormationとは

CloudFormationとは、テンプレートを用いたリソースのモデル化とプロビジョニングと公式では紹介されている。まあ要するにテンプレートを使って自動でリソースを作成・廃棄するための仕組みである。
そのテンプレートはJSONかYAMLを作って記述をする。Web上のコンソールではオンラインでGUIを使って記述をすることもできるのだが、限度があるため、YAMLで実際のテンプレートを記述することにする。

## テンプレートの書式

テンプレートは、以下の9つの要素からなるマップである。

- AWSTemplateFormatVersion テンプレートのバージョンを書く。文字列型であり、現在有効な値は2010-09-09のみである。省略した場合、現在の最新版を指定したものとみなす
- Description テンプレートのコメントを書く。文字列型であり、AWSTemplateFormatVersionより後に記述する必要がある。また、0バイト以上1024バイト以下である必要がある
- Metadata メタデータを書く。任意のマップを入れることができるが、一部のキーは特別な意味を持つ
- Parameters テンプレートに渡すパラメータを書く。ここで指定したパラメータを、プロビジョニング時に指定することができる。マップで指定する。マップのキーがパラメータ名である。マップの値はそのパラメータの設定であり、マップである。以下の要素がある
    - Type 唯一必須の要素で、このパラメータの型を指定する。許容される値はString・Number・List&lt;String&gt;・List&lt;Number&gt;・CommaDelimitedList、もしくはAWS固有のパラメータ型・SSMパラメータタイプのいずれかである
    - Description このパラメータの説明である。4000文字以下の文字列である必要がある
    - Default このパラメータのデフォルト値である
    - NoEcho このパラメータを出力で表示するときにマスキングするか。論理値型で、trueを指定するとマスキングされる
    - AllowedValues 許容される値のリスト。シーケンス型である必要がある
    - AllowedPattern 許容される値の正規表現。文字列型である必要がある
    - MinLength 最小文字数。数値型である必要がある
    - MaxLength 最大文字数。数値型である必要がある
    - MinValue 最小値。数値型である必要がある
    - MaxValue 最大値。数値型である必要がある
    - ConstraintDescription 制約違反時に出てくるメッセージ。文字列型である必要がある
- Mappings キーと名前付きの一連の値の関連付けを書く。マップ型である必要があり、各要素のキーがその関連付けの名前、値が一連の値である。一連の値はマップ型である。なお、キーには英数字のみを指定できる
- Conditions 条件定義を書く。この条件はリソース定義のときに参照可能で、その条件を満たしたときにだけリソースを作成するように書くことができる。マップで記述する。キーが条件式の名前、値がその条件の式である
- Transform CloudFormationが処理するマクロの指定。Lambdaを使うときにSAMのバージョンを指定するためによく使う
- Resources 唯一必須のパラメータ。どのリソースをプロビジョニングするか指定する。マップであり、キーにリソースのこのテンプレート上での名前(論理ID)、値にそのリソース設定のマップを書く。そのマップには以下の2つの要素がある
    - Type そのリソースのタイプ。例えばAWS::EC2::InstanceならEC2インスタンスである
    - Properties そのリソースの設定。設定項目はTypeごとに異なる
- Outputs 他のスタック(プロビジョニングの内容)にインポートしたり、応答として返したり、CloudFormationコンソールで出力する値の宣言。マップであり、キーにその出力の名前(論理ID)、値にその出力の定義のマップを記述する。そのマップの要素は以下の通り
    - Description 説明文字列
    - Value 必須で、出力されるプロパティの値
    - Export クロススタック参照で、参照元へエクスポートする名前。Nameというキーで、値にエクスポートする値を指定する

結局、各リソースごとに指定するプロパティがわからないと何もできないが、リファレンスを参照すればわかるので、AWSのドキュメントを参照すること。

## 具体的な記述例

今回用いるリソースは以下の通りである。

- DynamoDB
- Cognito
- Lambda
- API Gateway

それぞれの記述は以下の通りである。

### DynamoDB

オートスケールがない場合のDynamoDBの記述は以下の通りである。

```yaml
Resources:
    dynamoTable:
        Type: AWS::DynamoDB::Table
        Properties:
            AttributeDefinitions:
                -
                    AttributeName: Id
                    AttributeType: 'S'
                -
                    AttributeName: Timestamp
                    AttributeType: 'N'
                -
                    AttributeName: Type
                    AttributeType: 'S'
            KeySchema:
                -
                    AttributeName: Id
                    KeyType: HASH
                -
                    AttributeName: Timestamp
                    KeyType: RANGE
            GlobalSecondaryIndexes:
                -
                    IndexName: GSI
                    KeySchema:
                        -
                            AttributeName: Type
                            KeyType: HASH
                        -
                            AttributeName: Timestamp
                            KeyType: RANGE
                    Projection:
                        ProjectionType: ALL
                    ProvisionedThroughput:
                        ReadCapacityUnits: 5
                        WriteCapacityUnits: 5
            ProvisionedThroughput:
                ReadCapacityUnits: 5
                WriteCapacityUnits: 5
```

この指定により、以下のような設定でDynamoDBのテーブルが作成される。設定は以下の通り。

- IdというPartition Key、TimestampというSort Keyを持つ
- Idは文字列型、Timestampは数値型、Typeは文字列型である
- Global Secondary IndexとしてGSIというものが定義されており、それは射影としてすべての属性を持つ。パーティションキーとしてType、ソートキーとしてTimestampを持つ
- 本体のテーブル、GSI、ともにプロビジョニングされているスループットは読み書きともに5ユニットである
    - 1RCUで1項目4KBまでの強力な整合性のある読み込みを1秒に1回実行できる。結果整合性のある読み込みは1回あたり0.5RCU、トランザクション読み込みは1回あたり2RCUである
    - 1WCUで1項目1KBまでの標準の書き込み要求を1秒に1回実行できる。トランザクション書き込みは1回あたり2WCU必要である

この設定ではオートスケールしないため、キャパシティをオーバーするとスロットルする。このため、オートスケールを可能にするための設定を加える。オートスケールするDynamoDBは、以下のような記述になる。

```yaml
Resources:
    dynamoTable:
        Type: AWS::DynamoDB::Table
        Properties:
            AttributeDefinitions:
                -
                    AttributeName: Id
                    AttributeType: 'S'
                -
                    AttributeName: Timestamp
                    AttributeType: 'N'
                -
                    AttributeName: Type
                    AttributeType: 'S'
            KeySchema:
                -
                    AttributeName: Key
                    KeyType: HASH
                -
                    AttributeName: Timestamp
                    KeyType: RANGE
            GlobalSecondaryIndexes:
                -
                    IndexName: GSI
                    KeySchema:
                        -
                            AttributeName: Type
                            KeyType: HASH
                        -
                            AttributeName: Timestamp
                            KeyType: RANGE
                    Projection:
                        ProjectionType: ALL
                    ProvisionedThroughput:
                        ReadCapacityUnits: 5
                        WriteCapacityUnits: 5
            ProvisionedThroughput:
                ReadCapacityUnits: 5
                WriteCapacityUnits: 5
    dynamoTableReadCapacityTarget:
        Type: AWS::ApplicationAutoScaling::ScalableTarget
        Properties:
            MaxCapacity: 400
            MinCapacity: 5
            ResourceId: !Join
                - /
                -   - table
                    - !Ref dynamoTable
            RoleARN: !GetAtt dynamoTableScalingRole.Arn
            ScalableDimension: dynamodb:table:ReadCapacityUnits
            ServiceNamespace: dynamodb
    dynamoTableWriteCapacityTarget:
        Type: AWS::ApplicationAutoScaling::ScalableTarget
        Properties:
            MaxCapacity: 400
            MinCapacity: 5
            ResourceId: !Join
                - /
                -   - table
                    - !Ref dynamoTable
            RoleARN: !GetAtt dynamoTableScalingRole.Arn
            ScalableDimension: dynamodb:table:WriteCapacityUnits
            ServiceNamespace: dynamodb
    dynamoTableGSIReadCapacityTarget:
        Type: AWS::ApplicationAutoScaling::ScalableTarget
        Properties:
            MaxCapacity: 400
            MinCapacity: 5
            ResourceId: !Join
                - /
                -   - table
                    - !Ref dynamoTable
                    - index
                    - GSI
            RoleARN: !GetAtt dynamoTableScalingRole.Arn
            ScalableDimension: dynamodb:index:ReadCapacityUnits
            ServiceNamespace: dynamodb
    dynamoTableGSIWriteCapacityTarget:
        Type: AWS::ApplicationAutoScaling::ScalableTarget
        Properties:
            MaxCapacity: 400
            MinCapacity: 5
            ResourceId: !Join
                - /
                -   - table
                    - !Ref dynamoTable
                    - index
                    - GSI
            RoleARN: !GetAtt dynamoTableScalingRole.Arn
            ScalableDimension: dynamodb:index:WriteCapacityUnits
            ServiceNamespace: dynamodb
    dynamoTableScalingRole:
        Type: AWS::IAM::Role
        Properties:
            AssumeRolePolicyDocument:
                Version: '2012-10-17'
                Statement:
                    -
                        Effect: Allow
                        Principal:
                            Service:
                                - application-autoscaling.amazonaws.com
                        Action: 'sts:AssumeRole'
            Path: '/'
            Policies:
                -
                    PolicyName: 'root'
                    PolicyDocument:
                        Version: '2012-10-17'
                        Statement:
                            -
                                Effect: Allow
                                Action:
                                    - 'dynamodb:DescribeTable'
                                    - 'dynamodb:UpdateTable'
                                    - 'cloudwatch:PutMetricAlarm'
                                    - 'cloudwatch:DescribeAlarms'
                                    - 'cloudwatch:GetMetricStatistics'
                                    - 'cloudwatch:SetAlarmState'
                                    - 'cloudwatch:DeleteAlarms'
                                Resource: '*'
    dynamoTableReadScalingPolicy:
        Type: AWS::ApplicationAutoScaling::ScalingPolicy
        Properties:
            PolicyName: dynamoTableReadScalingPolicy
            PolicyType: TargetTrackingScaling
            ScalingTargetId: !Ref dynamoTableReadCapacityTarget
            TargetTrackingScalingPolicyConfiguration:
                TargetValue: 70.0
                ScaleInCooldown: 900
                ScaleOutCooldown: 120
                PredefinedMetricSpecification:
                    PredefinedMetricType: DynamoDBReadCapacityUtilization
    dynamoTableWriteScalingPolicy:
        Type: AWS::ApplicationAutoScaling::ScalingPolicy
        Properties:
            PolicyName: dynamoTableWriteScalingPolicy
            PolicyType: TargetTrackingScaling
            ScalingTargetId: !Ref dynamoTableWriteCapacityTarget
            TargetTrackingScalingPolicyConfiguration:
                TargetValue: 70.0
                ScaleInCooldown: 900
                ScaleOutCooldown: 120
                PredefinedMetricSpecification:
                    PredefinedMetricType: DynamoDBWriteCapacityUtilization
    dynamoTableGSIReadScalingPolicy:
        Type: AWS::ApplicationAutoScaling::ScalingPolicy
        Properties:
            PolicyName: dynamoTableGSIReadScalingPolicy
            PolicyType: TargetTrackingScaling
            ScalingTargetId: !Ref dynamoTableGSIReadCapacityTarget
            TargetTrackingScalingPolicyConfiguration:
                TargetValue: 70.0
                ScaleInCooldown: 900
                ScaleOutCooldown: 120
                PredefinedMetricSpecification:
                    PredefinedMetricType: DynamoDBReadCapacityUtilization
    dynamoTableGSIWriteScalingPolicy:
        Type: AWS::ApplicationAutoScaling::ScalingPolicy
        Properties:
            PolicyName: dynamoTableGSIWriteScalingPolicy
            PolicyType: TargetTrackingScaling
            ScalingTargetId: !Ref dynamoTableGSIWriteCapacityTarget
            TargetTrackingScalingPolicyConfiguration:
                TargetValue: 70.0
                ScaleInCooldown: 900
                ScaleOutCooldown: 120
                PredefinedMetricSpecification:
                    PredefinedMetricType: DynamoDBWriteCapacityUtilization
```

この指定は、こういうことである

- 先ほどと同じ設定でDynamoDBテーブルを作成する
- Application Auto Scalingのターゲットを4つ作成する。それぞれRCU・WCU・GSIのRCU・GSIのWCUであり、最小値5、最大値400で設定している
- IAMロールを作成する。これは以下のような内容を持つ
    - application-autoscaling.amazonaws.com に権限を委譲する
    - 以下の内容を許可する
        - DynamoDBテーブルの詳細を取得・更新する
        - CloudWatchアラームを作成・更新・名前での検索・状態設定・削除できる
        - CloudWatchメトリックの値を読み取りできる
- Application Auto Scalingのポリシーを4つ作成する。オートスケールのターゲットは先程作成したもので、いずれもキャパシティ使用率70%に到達するとオートスケール、スケールアウトのクールダウンは120秒、スケールインのクールダウンは900秒である

要するに、RCU・WCU・GSIのRCU・GSIのWCUを5以上400以下でオートスケールするようになる、ということである。

### Cognito

ユーザープールを定義する必要があるのだが、その前にユーザープールのIdP設定を書く必要があるらしい。このため、書き方は以下の通りとなる。

```yaml
Parameters:
    GoogleClientId:
        Type: String
        Description: 'Google API client ID'
    GoogleClientSecret:
        Type: String
        NoEcho: true
        Description: 'Google API client secret'
    AppBaseUrl:
        Type: String
        Description: 'App URL base'
Resources:
    userPoolProvider:
        Type: AWS::Cognito::UserPoolIdentityProvider
        Properties:
            UserPoolId: !Ref userPool
            ProviderName: Google
            ProviderType: Google
            AttributeMapping:
                email: emailAddress
            ProviderDetails:
                client_id: !Ref GoogleClientId
                client_secret: !Ref GoogleClientSecret
                authorize_scopes: email openid
    userPool:
        Type: AWS::Cognito::UserPool
        Properties:
            AdminCreateUserConfig:
                AllowAdminCreateUserOnly: false
            AliasAttributes:
                - email
            Schema:
                -
                    AttributeDataType: String
                    DeveloperOnlyAttribute: false
                    Name: email
                    Mutable: true
                    Required: false
                -
                    AttributeDataType: String
                    DeveloperOnlyAttribute: false
                    Name: role
                    Mutable: true
                    Required: false
    userPoolClient:
        Type: AWS::Cognito::UserPoolClient
        Properties:
            ClientName: 'ConventionCenterAuth'
            ReadAttributes:
                - email
                - 'custom:role'
            GenerateSecret: false
            SupportedIdentityProviders:
                - COGNITO
                - Google
            UserPoolId: !Ref userPool
            WriteAttributes:
                - email
                - 'custom:role'
            AllowedOAuthFlows:
                - code
            AllowedOAuthFlowsUserPoolClient: true
            AllowedOAuthScopes:
                - email
                - openid
                - aws.cognito.signin.user.admin
                - profile
            CallbackURLs:
                - http://localhost:8080/
                - !Ref AppBaseUrl
            LogoutURLs:
                - http://localhost:8080/
                - !Ref AppBaseUrl
```

この指定は、こういうことである。

- ユーザープールを以下の設定で作成する
    - 属性はemail(文字列)とrole(文字列)の2つ
    - email属性でのログインを許可
    - サインアップは誰でも可能
- そのユーザープールに対してログイン可能なIdPを以下の設定で作成する
    - プロバイダ名はGoogle
    - Googleを使ってサインインする
    - 取得した属性emailAddressをemail属性にマッピング
    - emailとopenidをスコープとしてOAuthリクエストを行う。その際のクライアントIDとクライアント秘密鍵はパラメータで指定する。クライアント秘密鍵は表示時にマスキングされる
- そのユーザープールのアプリクライアントを以下の設定で作成する
    - emailとroleを読み書き可能
    - Cognito自身の認証とGoogle認証をサポート
    - コールバックURL・サインアウトURLはローカルのURLとアプリのベースURLを指定
- CognitoのユーザープールにOAuthでサインイン可能

ドメインや証明書の設定はしていないため、必要に応じてマネジメントコンソールから設定すること。

### S3+CloudFront

S3+CloudFrontの設定は以下の通りである。ドメインの設定はあとから行うのでここでは行わない。
基本的な説明は https://dev.classmethod.jp/cloud/aws/s3-cloudfront-with-oai-by-cloudformation/ の通りである。

```yaml
Resources:
    contentBucket:
        Type: AWS::S3::Bucket
        # 削除時にバケットを維持する
        # これを指定しないとスタック削除時に詰む
        DeletionPolicy: Retain
    bucketCFAccessIdConf:
        Type: AWS::CloudFront::CloudFrontOriginAccessIdentity
        Properties:
            CloudFrontOriginAccessIdentityConfig:
                Comment: !Ref AWS::StackName
    contentBucketPolicy:
        Type: AWS::S3::BucketPolicy
        Properties:
            Bucket: !Ref contentBucket
            PolicyDocument:
                Statement:
                    -
                        Action: s3:GetObject
                        Effect: Allow
                        Resource: !Join
                            - ':'
                            -   - 'arn:aws:s3::'
                                - !Join
                                    - /
                                    -   - !Ref contentBucket
                                        - '*'
                        Principal:
                            AWS: !Join
                                - /
                                -   - arn:aws:iam::cloudfront:user
                                    - !Join
                                        - ' '
                                        -   - 'CloudFront Origin Access Identity'
                                            - !Ref bucketCFAccessIdConf
    contentDistribution:
        Type: AWS::CloudFront::Distribution
        Properties:
            DistributionConfig:
                Origins:
                    -
                        Id: S3Origin
                        DomainName: !GetAtt contentBucket.DomainName
                        S3OriginConfig:
                            OriginAccessIdentity: !Join
                                - /
                                -   - origin-access-identity
                                    - cloudfront
                                    - !Ref bucketCFAccessIdConf
                Enabled: true
                DefaultRootObject: index.html
                Comment: !Join
                    - ' '
                    -   - !Ref AWS::StackName
                        - distribution
                DefaultCacheBehavior:
                    TargetOriginId: S3Origin
                    ForwardedValues:
                        QueryString: false
                    ViewerProtocolPolicy: redirect-to-https
```

これにより、空のバケットが作成され、CloudFront配信が行われる。独自ドメインの設定とSSL証明書の設定は後ほどマネジメントコンソールなどから行うこと。

### Lambda

基本的なLambdaの記述は以下の通りである。なお、DynamoDBは先程の設定どおりdynamoTableというキーで作ったものとする。

```yaml
Transform: 'AWS::Serverless-2016-10-31'
Resources:
    dynamoTable:
        Type: AWS::DynamoDB::Table
        # 以下略
    accessDynamoTablePolicy:
        Type: AWS::IAM::ManagedPolicy
        Properties:
            Description: Access to app DynamoDB table
            Path: /
            PolicyDocument:
                Version: '2012-10-17'
                Statement:
                    -
                        Effect: Allow
                        Action:
                            - 'dynamodb:BatchGetItem'
                            - 'dynamodb:BatchWriteItem'
                            - 'dynamodb:ConditionCheckItem'
                            - 'dynamodb:PutItem'
                            - 'dynamodb:DescribeTable'
                            - 'dynamodb:DeleteItem'
                            - 'dynamodb:GetItem'
                            - 'dynamodb:Scan'
                            - 'dynamodb:Query'
                            - 'dynamodb:UpdateItem'
                        Resource:
                             - !Join
                                - ':'
                                -   - 'arn:aws:dynamodb'
                                    - !Ref AWS::Region
                                    - !Ref AWS::AccountId
                                    - !Join
                                        - '/'
                                        -   - table
                                            - !Ref dynamoTable
                            - !Join
                                - ':'
                                -   - 'arn:aws:dynamodb'
                                    - !Ref AWS::Region
                                    - !Ref AWS::AccountId
                                    - !Join
                                        - '/'
                                        -   - table
                                            - !Ref dynamoTable
                                            - index
                                            - GSI
    getIdolsLambda:
        Type: AWS::Serverless::Function
        Properties:
            CodeUri:
                Bucket: src-bucket
                Key: initLambda.zip
            Handler: lambda_function.lambda_handler
            Runtime: python3.7
            Timeout: 10
            MemorySize: 128
            Policies:
                - !Ref accessDynamoTablePolicy
            Environment:
                Variables:
                    TABLE_NAME: !Ref dynamoTable
    getIdolsLambdaLog:
        Type: AWS::Logs::LogGroup
        Properties:
            LogGroupName: !Join
                - '/'
                -   - '/aws/lambda'
                    - !Ref getIdolsLambda
            RetentionInDays: 30
```

これにより、以下のような設定でリソースが作成される。

- dynamoTableで作成したDynamoDBテーブル及びそのGSIへの読み書き削除の権限が許可されるポリシー
- 基本的な権限と上記権限が付与されたLambda関数
- 上記関数がアクセスするLambdaロググループ

なお、事前にS3のsrc\_bucketにinitLambda.zipというデプロイパッケージをアップロードすることを忘れないこと。

### API Gateway

API Gatewayの記述は以下の通りである。なお、各種リソースはこれまで書いてきたものの通りとする。

```yaml
Resources:
    userPool:
        Type: AWS::Cognito::UserPool
        # 以下略
    getIdolsLambda:
        Type: AWS::Serverless::Function
        # 以下略
    createIdolLambda:
        Type: AWS::Serverless::Function
        # 以下略。だいたいgetIdolsLambdaと同じ
    apiGateway:
        Type: AWS::ApiGateway::RestApi
        Properties:
            Description: 'Convention center REST API'
            Name: 'Convention Center API'
            EndpointConfiguration:
                Types:
                    - REGIONAL
    apiGatewayAuthorizer:
        Type: AWS::ApiGateway::Authorizer
        Properties:
            ProviderARNs:
                - !GetAtt userPool.Arn
            AuthorizerResultTtlInSeconds: 300
            Type: COGNITO_USER_POOLS
            IdentitySource: method.request.header.Authorization
            Name: RestApiAuthorizer
            RestApiId: !Ref apiGateway
    idolsResource:
        Type: AWS::ApiGateway::Resource
        Properties:
            RestApiId: !Ref apiGateway
            ParentId: !GetAtt apiGateway.RootResourceId
            PathPart: idols
    optionsIdolsMethod:
        # これは https://stackoverflow.com/questions/40292888/ を参考に
        Type: AWS::ApiGateway::Method
        Properties:
            AuthorizationType: NONE
            RestApiId: !Ref apiGateway
            ResourceId: !Ref idolsResource
            HttpMethod: OPTIONS
            Integration:
                IntegrationResponses:
                    -
                        StatusCode: 200
                        ResponseParameters:
                            method.response.header.Access-Control-Allow-Headers:
                                # 実際は文字列内は改行しない
                                "'Content-Type,X-Amz-Date,Authorization,
                                X-Api-Key,X-Amz-Security-Token'"
                            method.response.header.Access-Control-Allow-Methods:
                                "'GET,POST,OPTIONS'"
                            method.response.header.Access-Control-Allow-Origin:
                                "'*'"
                        ResponseTemplates:
                            application/json: ''
                PassthroughBehavior: WHEN_NO_MATCH
                RequestTemplates:
                    application/json: '{"statusCode": 200}'
                Type: MOCK
            MethodResponses:
                -
                    StatusCode: 200
                    ResponseModels:
                        application/json: 'Empty'
                    ResponseParameters:
                        method.response.header.Access-Control-Allow-Headers:
                            false
                        method.response.header.Access-Control-Allow-Methods:
                            false
                        method.response.header.Access-Control-Allow-Origin:
                            false
    getIdolsMethodPermission:
        Type: AWS::Lambda::Permission
        Properties:
            FunctionName: !GetAtt getIdolsLambda.Arn
            Action: lambda:InvokeFunction
            Principal: apigateway.amazonaws.com
            SourceArn: !Join
                - ':'
                -   - 'arn:aws:execute-api'
                    - !Ref AWS::Region
                    - !Ref AWS::AccountId
                    - !Join
                        - '/'
                        -   - !Ref apiGateway
                            - '*'
                            - GET
                            - idols
    getIdolsMethod:
        Type: AWS::ApiGateway::Method
        Properties:
            AuthorizationType: NONE
            RestApiId: !Ref apiGateway
            ResourceId: !Ref idolsResource
            HttpMethod: GET
            Integration:
                Type: AWS_PROXY
                IntegrationHttpMethod: POST
                Uri: !Join
                    - ':'
                    -   - arn:aws:apigateway
                        - !Ref AWS::Region
                        - lambda
                        - !Join
                            - /
                            -   - path
                                - '2015-03-31'
                                - functions
                                - !GetAtt getIdolsLambda.Arn
                                - invocations
        DependsOn: getIdolsMethodPermission
    createIdolPermission:
        Type: AWS::Lambda::Permission
        Properties:
            FunctionName: !GetAtt createIdolLambda.Arn
            Action: lambda:InvokeFunction
            Principal: apigateway.amazonaws.com
            SourceArn: !Join
                - ':'
                -   - 'arn:aws:execute-api'
                    - !Ref AWS::Region
                    - !Ref AWS::AccountId
                    - !Join
                        - '/'
                        -   - !Ref apiGateway
                            - '*'
                            - POST
                            - idols
    createIdolMethod:
        Type: AWS::ApiGateway::Method
        Properties:
            AuthorizationType: COGNITO_USER_POOLS
            AuthorizerId: !Ref apiGatewayAuthorizer
            RestApiId: !Ref apiGateway
            ResourceId: !Ref idolsResource
            HttpMethod: POST
            Integration:
                Type: AWS_PROXY
                IntegrationHttpMethod: POST
                Uri: !Join
                    - ':'
                    -   - arn:aws:apigateway
                        - !Ref AWS::Region
                        - lambda
                        - !Join
                            - /
                            -   - path
                                - '2015-03-31'
                                - functions
                                - !GetAtt createIdolLambda.Arn
                                - invocations
        DependsOn: createIdolPermission
    apiDeployment:
        Type: AWS::ApiGateway::Deployment
        Properties:
            Description: API deployment
            RestApiId: !Ref apiGateway
        DependsOn:
            - optionsIdolsMethod
            - getIdolsMethod
            - createIdolMethod
    apiStage:
        Type: AWS::ApiGateway::Stage
        Properties:
            DeploymentId: !Ref apiDeployment
            Description: API stage
            RestApiId: !Ref apiGateway
            StageName: prod
```

これにより、CORS対応のAPIが作成される。APIのルートディレクトリは/prodで、その下に/idolsというAPIがある。そのAPIはOPTIONSとGETとPOSTが存在し、このうちPOSTはCognito経由での認証を要する。GETとPOSTはLambda統合プロキシ経由でLambda関数に渡される。

## DynamoDBの基本

DynamoDBは、NoSQLと言われるデータベースの1種である。以下のような特徴を持つ。

1. データはPartition Key、もしくはPartition KeyとSort Keyの組で一意に識別する
2. 検索用にGlobal Secondary Indexを利用することができる。Global Secondary IndexもPartition Key、もしくはPartition KeyとSort Keyの組で識別するが一意である必要はない
3. 検索は原則としてPartition Key、Partition KeyとSort Keyの組でだけ行うことができる。なお、Global Secondary Indexでの検索も可能だが、必ずメインのテーブルか同じGlobal Secondary Indexだけで完結する必要がある
4. Partition Keyの検索は等しいのみ可能で必須、Sort Keyの検索は等しい、小さい、大きい、以上、以下、間、始まるの7種類で検索可能で任意である
5. 4の検索のあと、フィルタをかけることで検索を補完できるが、結局4でヒットした内容を全部取得したあとにフィルタをかけるので(件数の絞り込みがある場合はその絞り込みのあとにフィルタがかかる)あまり得意ではない
6. 読み込みは3種類存在する。1つが結果整合性のある読み込み、もう1つが強力な整合性のある読み込み、最後の1つがトランザクション読み込みである。Global Secondary Index経由で検索する場合は結果整合性のある読み込みしか利用ができない。読み込みにおいて必要なキャパシティは強力な整合性のある読み込みを1として結果整合性のある読み込みが0.5、トランザクション読み込みが2である。4KBまでの読み込みにおいて、1回の読み込みは強力な整合性のある読み込みで1RCUである
7. 書き込みは2種類存在する。1つが通常の書き込み、もう1つがトランザクション書き込みである。後者は前者の2倍キャパシティが必要である。1KBまでの書き込みにおいて、1回の書き込みは1WCUである
8. 結果整合性のある読み込みでは、通常1秒以内ではあるが、書き込みの反映のラグがある

アンチケースとして、連番を振ってはならないというのがあるため、書き込み番号の管理は行わないこととする。アイドルの並び順というのを現在のスキーマでは管理できないが、今回はアイドルの並び順のスキーマの管理はDB上では諦め、コード側で行うこととした。

## Python3でのLambdaの書き方

Python3でLambdaはこのように記述する。

```python
import json
import os

import boto3

def lambda_function(event, context):
    """イベントハンドラです
    """

    # 環境変数はos.environ経由で取得する
    table_name = os.environ['TABLE_NAME']
    # 自分のいるリージョン名はこのように取得する
    region_name = boto3.session.Session().region_name
    # DynamoDBのテーブルを取得するにはこのようにする
    dynamo = boto3.resource('dynamodb', region_name=region_name)
    table = dynamo.Table(table_name) # pylint: disable=no-member
    # 原則としてQueryを使うこと。Scanは遅い
    res = table.query(
        IndexName='GSI',
        KeyConditions={
            'Type': {
                'AttributeValueList': ['Idol'],
                'ComparisonOperator': 'EQ'
            }
        }
    )
    # DynamoDBで取得したアイテムをそのまま返す。必要なら適宜加工すること
    return {
        # HTTPステータスコード。200はOKである
        'statusCode': 200,
        # HTTPのヘッダー
        'headers': {
            # これを書かないとAjaxでCORSエラーになる
            'Access-Control-Allow-Origin': '*'
        },
        # 出力をJSON形式の文字列とする
        'body': json.dumps(res['Items'])
    }
```

これのファイル名をlambda\_function.pyとして保存し、このファイルだけをzipファイルにする。それをS3にアップロードしてCloudFormationのKeyで指定する。
注意点としては、コード更新はCloudFormation経由ではできないため、一度デプロイした関数の更新はCLIを使うなり、マネジメントコンソールを使うなりして行う。

## フロントのコンテンツの作り方

フロントのコンテンツは、今回、Vue.js+TypeScriptを用いて実装することとした。構成は以下の通りである

```
/
|-dst (このディレクトリの中身をS3にアップロードする)
| |-css (CSSが入るディレクトリ)
| |-img (画像が入るディレクトリ)
| |-js (JavaScriptが入るディレクトリ)
| |-index.html (メインのHTML)
| |-privacy.html (プライバシーポリシーのHTML)
| --site-config.json (サイト設定を入れたJSON、これは後で使う)
|-src (このディレクトリの中で開発を行う)
| |-components (この中に各種コンポーネントを入れる)
| |-img (この中の画像がdst/imgにコピーされる)
| |-scss (SCSSが入るディレクトリ)
| |-index.ts (メイン関数が入るファイル)
| --vue-shims.d.ts (型定義ファイル)
|-package.json (必要なNodeモジュールを定義したファイル)
|-tsconfig.json (TypeScriptの設定ファイル)
|-tslint.json (TSLintの設定ファイル)
--webpack.config.js (WebPackの設定ファイル)
```

まず、package.jsonから見ることにする。

### package.json

package.jsonは、以下のようになっている。
```json
{
    "name": "project-name",
    "version": "1.0.0",
    "description": "Convention center",
    "main": "index.js",
    "scripts": {
        "build": "webpack --config webpack.config.js",
        "watch": "webpack --config webpack.config.js --watch",
        "test": "echo \"Error: no test specified\" && exit 1"
    },
    "author": "Your name",
    "license": "ISC",
    "devDependencies": {
        "copy-webpack-plugin": "^5.0.4",
        "css-loader": "^3.2.0",
        "fibers": "^4.0.2",
        "file-loader": "^4.2.0",
        "mini-css-extract-plugin": "^0.8.0",
        "node-sass": "^4.12.0",
        "sass": "^1.23.0",
        "sass-loader": "^8.0.0",
        "string-replace-loader": "^2.2.0",
        "ts-loader": "^6.2.0",
        "tslint": "^5.20.0",
        "tslint-loader": "^3.5.4",
        "typescript": "^3.6.4",
        "vue": "^2.6.10",
        "vue-loader": "^15.7.1",
        "vue-property-decorator": "^8.3.0",
        "vue-style-loader": "^4.1.2",
        "vue-template-compiler": "^2.6.10",
        "vue-tslint-loader": "^3.5.6",
        "webpack": "^4.41.2",
        "webpack-cli": "^3.3.9"
    },
    "dependencies": {
        "@types/graphql": "^14.5.0",
        "aws-amplify": "^1.2.4"
    }
}
```

それぞれのパッケージの役割は以下の通りである。

- node-sass・sass・sass-loader SCSSを取り扱うためのパッケージ
- css-loader・mini-css-extract-plugin CSSを取り扱うためのパッケージ
- ts-loader・tslint・tslint-loader・typescript TypeScriptを取り扱うためのパッケージ
- vue・vue-loader・vue-property-decorator・vue-style-loader・vue-template-loader・vue-tslint-loader vueファイルを取り扱うためのパッケージ
- file-loader ファイルを取り扱うためのパッケージ
- copy-webpack-plugin・webpack・webpack-cli webpackに関するパッケージ
- fibers 上記に関する依存関係
- aws-amplify AWSのCognito認証を行うためのパッケージ
- @types/graphql aws-amplifyに含まれる内容の型定義

`npm install`することで必要なパッケージが入る。

### tsconfig.json

次に、tsconfig.jsonを見る。不要なコメントはバッサリ削った。

```json
{
    "compilerOptions": {
        "target": "es5",
        "module": "commonjs",
        "sourceMap": true,
        "strict": true,
        "noImplicitAny": true,
        "noUnusedLocals": true,
        "baseUrl": ".",
        "paths": {
            "@/*": ["src/*"]
        },
        "esModuleInterop": true,
        "experimentalDecorators": true
    },
    "include": ["src/**/*.ts", "src/**/*.vue"],
    "exclude": ["node_modules"]
}
```

つまり、こういうことである。

- ES5形式で出力する(IE11以上対象)
- CommonJSを使う
- ソースマップを出力する
- 厳密な型チェックを有効にする
- 暗黙のanyを許可しない
- 未使用のローカル変数に関してエラーを出力する
- ベースURLをこのディレクトリにする
- @/で始まるパスはsrcをルートとする
- CommonJSのモジュールとEcmaScriptのモジュールの相互変換を有効にする
- デコレータ機能を有効にする
- src以下のtsファイルとsrc以下のvueファイルを含め、node\_modules以下を除外する

### tslint.json

文法チェック定義であるtslint.jsonは、以下の内容である。

```json
{
    "defaultSeverity": "warning",
    "extends": ["tslint:recommended"],
    "linterOptions": {
        "exclude": ["node_modules/**"]
    },
    "rules": {
        "quotemark": [true, "single"],
        "indent": [true, "spaces", 2],
        "interface-name": false,
        "ordered-imports": false,
        "object-literal-sort-keys": false,
        "no-consecutive-blank-lines": false,
        "no-empty": false,
        "no-console": [true, "warning"]
    }
}
```

要するに、

- 推奨された形式を拡張する
- node\_modules以下は気にしない
- 単引用符を用いる
- インデントはスペース2つ
- インターフェースの名前の頭文字がIで始まるという規則は採用しない
- 順序通りのインポートの規則は採用しない
- オブジェクトのキーのアルファベット順規則は採用しない
- 連続空行禁止の規則は採用しない
- 空ブロック禁止の規則は採用しない
- console.warningは禁止するが他のconsoleメソッドは禁止しない

ということである。

### webpack.config.js

一番面倒なwebpack.config.jsである。これは以下のような内容である。

```javascript
const path = require('path');
const VueLoaderPlugin = require('vue-loader/lib/plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const CopyWebpackPlugin = require('copy-webpack-plugin');

module.exports = {
    mode: 'development',
    entry: './src/main.ts',
    module: {
        rules: [
            {
                test: /\.vue$/,
                use: [
                    'vue-loader',
                ],
            },
            {
                test: /\.mjs$/,
                include: /node_modules/,
                type: 'javascript/auto',
            },
            {
                test: /\.scss$/,
                use: [
                    MiniCssExtractPlugin.loader,
                    'css-loader',
                    'sass-loader'
                ],
            },
            {
                enforce: 'pre',
                loader: 'vue-tslint-loader',
                test: /\.vue.(ts|tsx)$/,
                exclude: [
                    /node_modules/,
                ],
                options: {
                    emitErrors: true
                },
            },
            {
                enforce: 'pre',
                loader: 'tslint-loader',
                test: /\.ts$/,
                exclude: [
                    /node_modules/,
                    /components/
                ],
                options: {
                    emitErrors: true
                },
            },
            {
                loader: 'ts-loader',
                test: /\.ts$/,
                exclude: [
                    /node_modules/
                ],
                options: {
                    configFile: 'tsconfig.json',
                    appendTsSuffixTo: [/\.vue$/]
                },
            },
            {
                test: /\.(jpe?g|png|gif|svg)$/,
                use: [
                    {
                        loader: 'file-loader',
                        options: {
                            name: "[folder]/[name].[ext]",
                            outputPath: '../img/',
                        }
                    }
                ],
            },
        ],
    },
    resolve: {
        extensions: [ '.ts', '.js', '.vue' ],
        alias: {
            'vue$': 'vue/dist/vue.esm.js',
            '@': path.resolve(__dirname, 'src'),
        }
    },
    plugins: [
        new VueLoaderPlugin(),
        new MiniCssExtractPlugin({
            filename: '../css/app.css',
        }),
        new CopyWebpackPlugin([{
            from: '.',
            to: '../img/',
          }],
          { context: 'src/img/' }
        ),
    ],
    output: {
        library: 'VueApp',
        path: path.resolve(__dirname, 'dst', 'js'),
        filename: 'app.js',
        libraryTarget: 'umd'
    }
};
```

本番環境に出力するときは、modeをdevelopmentからproductionに変更すること。

### dst/index.html

index.htmlの中身はこんな感じである。

```html
<!DOCTYPE html>
<html lang="ja">
    <head>
        <meta charset="utf-8" />
        <title>コンベンションセンター</title>
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <link rel="stylesheet" href="css/app.css" />
    </head>
    <body>
        <div id="main"></div>
        <script type="text/javascript" src="js/app.js"></script>
        <script type="text/javascript">
        VueApp.init('#main');
        </script>
    </body>
</html>
```

VueAppという値は、先程のwebpack.config.jsのoutputのlibraryである。他に何も言うことはない。OGP画像などの定義は先に行うこと。

### src/vue-shims.d.ts

型定義なわけだが、内容は以下の通り。

```typescript
declare module '*.vue' {
    import Vue from 'vue';
    export default Vue;
}
```

### src/main.ts

メインプログラムである。内容は以下の通り。

```typescript
import App from '@/components/App.vue';
import Vue from 'vue';

const init = (target: string) => {
    // tslint:disable-next-line:no-unused-expression
    new Vue({
        el: target,
        template: '<App />',
        components: {
            App,
        },
    });
};

export { init };
```

前提として、以下の内容が含まれている。

- src/components/App.vueにルートコンポーネントが定義されている
- そのルートコンポーネント展開する
- 展開部分は、未使用の式があるという先程のTSLintの設定に違反しているが、これは回避できないので、例外として許容してもらう

### src/components/App.vue

さて、一番ルートとなるvueファイルだが、最初はこんな感じで作る。

```
<template>
    <div class="app_container">
    </div>
</template>
<script lang="ts">
import '@/scss/app.scss';
import {Component, Vue} from 'vue-property-decorator';
@Component
export default class App extends Vue {
}
</script>
```

これにより、

- app\_containerクラスのついたdiv要素を展開する
- src/scss/app.scssを読み込む

ということを実現する。あとはここから肉付けをしていけばよい。

### TypeScriptでCognitoのOpenID認証を実現する

これは、このような方針でやっていけばよいはずである。

```typescript
interface AuthApiConfig {
    region: string;
    userPoolId: string;
    userPoolWebClientId: string;
    oauth?: {
        domain: string;
        scope: string[];
        redirectSignIn?: string;
        redirectSignOut?: string;
        responseType: string;
    }
}

import Amplify, {Auth} from 'aws-amplify';
import {CognitoHostedUIIdentityProvider} from '@aws-amplify/auth/lib-esm/Auth';

export default class AuthApi {
    public static getConfig() {
        return new Promise<AuthApiConfig>((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.open('GET', '/site-config.json');
            xhr.responseType = 'json';
            xhr.addEventListener('load', () => {
                if (xhr.status >= 400) {
                    reject('Error code ' + xhr.status);
                }
                resolve(xhr.response as AuthApiConfig);
            });
            xhr.addEventListener('error', () => {
                reject('Error');
            });
            xhr.addEventListener('abort', () => {
                reject('Aborted');
            });
            xhr.send();
        });
    }
    constructor(config: AuthApiConfig) {
        Amplify.configure({Auth: config});
    }
    public async signIn() {
        await Auth.federatedSignIn({provider: CognitoHostedUIIdentityProvider.Google});
    }
    public async signOut() {
        await Auth.signOut();
    }
    public async getSignedInUser() {
        return await Auth.currentAuthenticatedUser();
    }
    public listenAuth() {
        return new Promise((resolve) => {
            Hub.listen('auth', ({payload: {event, data}}) => {
                if (event === 'signIn') {
                    resolve(data);
                }
            });
        });
    }
}
```

基本的な流れは、以下の通りである。

1. `AuthApi.getConfig` でAPIの設定を取得する
2. `AuthApi` オブジェクトを作成する
3. `listenAuth` の `Promise` の `then` でデータを受け取って、それが `CognitoUser` であることを確認したらそれを現在のユーザとするコールバックを定義する
4. `getSignedInUser` で現在サインインしているユーザを確認する。なお、 `CognitoUser` であることの確認を忘れずに

ひとまずここまでで、サインインの流れまでの説明ができた。ここで、 `CognitoUser` のユーザを `user` としたとしよう。認証つきAPIを呼び出すには以下のようにする。

1. `user.getSignInUserSession()!.getIdToken().getJwtToken()` により認証に利用するトークンを取得する
2. それを `Authorization` ヘッダーにセットする

これだけである。あとは普通にXMLHttpRequestを使うなりaxiosライブラリを使うなりご自由に。